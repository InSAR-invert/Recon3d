!  file: _reconutils.f90
!
!  Collection of utilities for recon3d
!
!  author:  B. Minchew
!  email:   bminchew@caltech.edu
!  date:    June 2013
!  version: 0.1.0 
!
!  f2py -c -m _reconutils _reconutils.f90 --opt="-O3" --f90exec=/opt/local/bin/gfortran
!           -L/Users/brentminchew/bin/lapack-3.4.2 -llapack -lrefblas -lgfortran
!
!  ==============================================================================
   subroutine defsolspace(metfile,numsc,doline,docol,rnkbool,addr,rnk,num,gmatr,lenaddr)
!  Define the solution space
!
!  Parameters
!  ----------
!  metfile  :  string
!              name of file containing scene info generated by _reconsolver.py
!  numsc    :  int
!              number of scenes
!  doline   :  int
!              number of lines in the final output 
!  docol    :  int
!              number of columns in the final output (and master scene)
!  rnkbool  :  int (0 or 1)
!              logical value:  True (=1) to ensure that G is rank 3 ***recommended
!              rank is determined using SVD; implemented in Lapack routine dgesvd
!
!  Outputs
!  -------
!  addr     :  1 x (doline*cols) int array
!              pixel locations (addresses) where number of nonnull scenes >= 3
!              addresses are given as linear so that x @ [row,col] as addr = row*cols+col 
!  rnk      :  1 x (doline*cols) float array
!              ranks of pixels located at addr               
!  num      :  1 x (doline*cols) float array
!              number of nonnull-valued scenes at addr
!  gmatr    :  int
!              number of rows in the G matrix 
!  lenaddr  :  int
!              valid length of addr array.  addr[lenaddr:] = null
! 
!

   implicit none
   character*1          delm
   character*250        metfile
   integer              numsc,doline,docol,rnkbool,gmatr,lenaddr,irnk
   integer              addr(doline*docol),fids(numsc,3),cols(numsc),jind
   integer              i,j,m,nchk,cnt,nonul,latlon(numsc,5)
   real*4               rnk(doline*docol),num(doline*docol),nulls(numsc,5)
   real*4               unw(numsc,docol),cor(numsc,docol),los(numsc,3*docol)
   real*4               losmat(numsc,3)
   character(len=250),dimension(numsc,3)::  filenms
   character(len=11),parameter:: fu='unformatted'
   character(len=6), parameter:: di='direct'

!f2py intent(in)  metfile,numsc,doline,cols,rnkbool
!f2py intent(out) addr,rnk,num,gmatr,lenaddr
   
   delm = ':'
   call parsemetfile(metfile,numsc,delm,fids,filenms,cols,nulls,latlon) 

   do i=1,numsc
      open(fids(i,1),file=filenms(i,1),access=di,form=fu,status='old',recl=4*cols(i))
      open(fids(i,2),file=filenms(i,2),access=di,form=fu,status='old',recl=4*cols(i))
      open(fids(i,3),file=filenms(i,3),access=di,form=fu,status='old',recl=3*4*cols(i))
   enddo

   lenaddr = 0
   gmatr = 0
   do i=1,doline
      call print_status(i,doline,2)
      call get_data_vecs(unw,cor,los,numsc,docol,fids,cols,nulls,latlon,i,cnt)
      if (cnt.ge.3) then
         do j=1,docol
            nonul = 0
            jind = 3*(j-1) + 1
            do m=1,numsc
               call interogate_data(unw(m,j),cor(m,j),los(m,jind:jind+2),nulls(m,1:3),nchk)
               if (nchk.eq.1) then 
                  nonul = nonul + 1
                  losmat(nonul,1:3) = los(m,jind:jind+2)
               endif
            enddo
            num((i-1)*docol+j) = real(nonul)  
            if (nonul.gt.2.and.rnkbool.eq.1) then
               call get_rank(losmat(:nonul,:),nonul,irnk)
               rnk((i-1)*docol+j) = real(irnk)
               if (irnk.ge.3) then
                  lenaddr = lenaddr + 1
                  addr(lenaddr) = (i-1)*docol+j-1
                  gmatr = gmatr + nonul
               endif
            elseif (nonul.gt.2) then
               lenaddr = lenaddr + 1
               addr(lenaddr) = (i-1)*docol+j-1
               gmatr = gmatr + nonul
            else
               rnk((i-1)*docol+j) = 0.d0
            endif 
         enddo
      else
         num((i-1)*docol+1:i*docol) =  0.d0          
         rnk((i-1)*docol+1:i*docol) =  0.d0
      endif
   enddo
   print *,''
   do i=1,numsc
      close(fids(i,1)); close(fids(i,2)); close(fids(i,3))
   enddo

   end subroutine

!  ==============================================================================
   subroutine get_gcd_vals(metfile,numsc,doline,docol,addr,lenaddr,gmatr,gmatv,gmatij,cdiv,dvec)
!  
!  Read input files and store the nonzero elements of G, Cd^-1 and d
!
!  Parameters
!  ----------
!  metfile  :  string
!              name of file containing scene info generated by _reconsolver.py
!  numsc    :  int
!              number of scenes
!  doline   :  int
!              number of lines in the final output 
!  docol    :  int
!              number of columns in the final output (and master scene)
!  addr     :  int vector
!              addresses of nonzero values (generated by defsolspace) 
!  lenaddr  :  int
!              len(addr)
!  gmatr    :  int
!              number of rows in G (output from defsolspace)
!
!  Outputs
!  -------
!  gmatv    :  1d float array
!              vector of nonzero elements of G
!  gmatij   :  1d int array (2xlen(gmatv))
!              vector of row and col locations for G in (cols appended to rows)
!  cdiv     :  1d float array
!              diagonal terms of Cd^-1
!  dvec     :  1d float array
!              nonnull data values 
!
   implicit none
   character*1          delm
   character*250        metfile
   integer              numsc,doline,docol,lenaddr,gmatr
   integer              addr(lenaddr),gmatij(2*3*gmatr)
   integer              fids(numsc,3),cols(numsc),jind,aind,gind
   integer              i,j,m,nchk,cnt,latlon(numsc,5),gmr
   real*4               gmatv(3*gmatr),cdiv(gmatr),dvec(gmatr),nulls(numsc,5)
   real*4               unw(numsc,docol),cor(numsc,docol),los(numsc,3*docol)
   real*8               corsq
   character(len=250),dimension(numsc,3)::  filenms
   character(len=11),parameter:: fu='unformatted'
   character(len=6), parameter:: di='direct'

!f2py intent(in)  gmatr,metfile,numsc,doline,docol,addr,lenaddr
!f2py intent(out) gmatv,gmatij,cdiv,dvec
 
   delm = ':'
   call parsemetfile(metfile,numsc,delm,fids,filenms,cols,nulls,latlon)

   do i=1,numsc
      open(fids(i,1),file=filenms(i,1),access=di,form=fu,status='old',recl=4*cols(i))
      open(fids(i,2),file=filenms(i,2),access=di,form=fu,status='old',recl=4*cols(i))
      open(fids(i,3),file=filenms(i,3),access=di,form=fu,status='old',recl=3*4*cols(i))
   enddo

   aind = 0  ! aind and gmr are zero-indexed for python
   gmr  = 0
   do i=1,doline
      call print_status(i,doline,2)
      call get_data_vecs(unw,cor,los,numsc,docol,fids,cols,nulls(:,1:3),latlon,i,cnt)
      do j=1,docol
         if (addr(aind+1).eq.(i-1)*docol+j-1) then
            jind = 3*(j-1)+1
            do m=1,numsc
               call interogate_data(unw(m,j),cor(m,j),los(m,jind:jind+2),nulls(m,1:3),nchk)
               if (nchk.eq.1) then
                  gind = 3*gmr+1 
                  gmatij(gind:gind+2) = gmr
                  gmatij(gmatr*3+gind)   = 3*aind
                  gmatij(gmatr*3+gind+1) = 3*aind + 1
                  gmatij(gmatr*3+gind+2) = 3*aind + 2
                  gmatv(gind:gind+2) = los(m,jind:jind+2)
                  gmr = gmr + 1
                  corsq = dble(cor(m,j))**2
                  cdiv(gmr) = sngl(dble(nulls(m,4))*corsq/(1.d0-corsq))
                  dvec(gmr) = sngl(dble(unw(m,j)) * dble(nulls(m,5)))
               endif
            enddo
            aind = aind + 1
            if (aind.ge.lenaddr) aind = aind - 1
         endif
      enddo
   enddo
   print *,''
   end subroutine

 
!  ==============================================================================
   subroutine laplace_builder(docol,addr,lenaddr,laplace,lapij)
!  Build Laplacian for the model vector
!
!  Parameters
!  ----------
!  docol    :     int
!                 columns in output image (= cols in master scene)
!  addr     :     1d int array
!                 array of addresses of nonzero values
!  lenaddr  :     int
!                 len(addr)
!
!  Outputs
!  -------
!  laplace  :     1d float array
!                 laplacian 
!
!
   implicit none
   integer        docol,lenaddr,tla
   integer        addr(lenaddr),lapij(2*3*lenaddr*5)
   integer        i,j,sl,mv(1),lind,left,right,above,below,row
   real*4         laplace(3*lenaddr*5),diag
!f2py intent(in)  docol,addr,lenaddr
!f2py intent(out) laplace,lapij

   tla = 3*lenaddr*5
   lind = 1 
   do i=1,lenaddr
      call print_status(i,lenaddr,2)
      row = 3*(i-1)  ! 0 indexed 
      diag = 0.e0
      left  = addr(i)-1
      right = addr(i)+1
      above = addr(i)-docol
      below = addr(i)+docol

      ! left must be positive and i > 1 for there to be a valid pixel to the left
      if (left.ge.0.and.i.gt.1) then
         if (addr(i-1).eq.left.and.mod(addr(i),docol).ne.0) then
            ! the way addresses are loaded means that if the pixel to the left is valid, it 
            ! will be at i-1. (Address is row*cols+col) For the pixel to be to the left of the 
            ! current pixel, the current pixel can't be on the left image boundary
            j = 3*(i-1-1)   ! 0 indexed
            laplace(lind) = -1.e0; lapij(lind) = row; lapij(tla+lind) = j; lind = lind + 1 
            laplace(lind) = -1.e0; lapij(lind) = row+1; lapij(tla+lind) = j+1; lind = lind + 1 
            laplace(lind) = -1.e0; lapij(lind) = row+2; lapij(tla+lind) = j+2; lind = lind + 1 
            diag = diag + 1.e0
         endif
      endif

      ! basically the same arguments as before
      if (right.lt.addr(lenaddr).and.i.lt.lenaddr) then
         if (addr(i+1).eq.right.and.mod(addr(i+1),docol).ne.0) then
            j = 3*(i-1+1)   ! 0 indexed
            laplace(lind) = -1.e0; lapij(lind) = row; lapij(tla+lind) = j; lind = lind + 1 
            laplace(lind) = -1.e0; lapij(lind) = row+1; lapij(tla+lind) = j+1; lind = lind + 1 
            laplace(lind) = -1.e0; lapij(lind) = row+2; lapij(tla+lind) = j+2; lind = lind + 1 
            diag = diag + 1.e0
         endif
      endif 

      if (above.ge.0) then
         sl = 0; if ((i-docol-1).gt.0) sl = (i-docol-1) ! don't search further back than what's possible
         if (any(addr(sl:i).eq.above)) then
            mv = minloc(abs(addr(sl:i)-above))
            j  = 3*(sl+mv(1)-1)
            laplace(lind) = -1.e0; lapij(lind) = row; lapij(tla+lind) = j; lind = lind + 1 
            laplace(lind) = -1.e0; lapij(lind) = row+1; lapij(tla+lind) = j+1; lind = lind + 1 
            laplace(lind) = -1.e0; lapij(lind) = row+2; lapij(tla+lind) = j+2; lind = lind + 1 
            diag = diag + 1.e0
         endif
      endif

      if (below.le.addr(lenaddr)) then
         sl = lenaddr; if ((i+docol+1).lt.lenaddr) sl = (i+docol+1)
         if (any(addr(i:sl).eq.below)) then
            mv = minloc(abs(addr(i:sl)-below))
            j  = 3*(i-1+mv(1)-1)
            laplace(lind) = -1.e0; lapij(lind) = row; lapij(tla+lind) = j; lind = lind + 1
            laplace(lind) = -1.e0; lapij(lind) = row+1; lapij(tla+lind) = j+1; lind = lind + 1
            laplace(lind) = -1.e0; lapij(lind) = row+2; lapij(tla+lind) = j+2; lind = lind + 1
            diag = diag + 1.e0
         endif
      endif
      laplace(lind) = diag; lapij(lind) = row; lapij(tla+lind) = row; lind = lind + 1; row = row + 1
      laplace(lind) = diag; lapij(lind) = row; lapij(tla+lind) = row; lind = lind + 1; row = row + 1
      laplace(lind) = diag; lapij(lind) = row; lapij(tla+lind) = row; lind = lind + 1; row = row + 1
   enddo
   laplace(lind:) = -10000.e0
   print *,''
   end subroutine
!  ==============================================================================
 
!  Gerneral, internal tools

!  ==============================================================================
   subroutine get_data_vecs(unw,cor,los,numsc,docol,fids,cols,nulls,latlon,i,cnt)
   implicit none
   integer              numsc,docol,i,m,cnt
   integer              latoff,sline,eline,bcol,scol
   integer              fids(numsc,3),cols(numsc),latlon(numsc,5)
   real*4               nulls(numsc,3),unw(numsc,docol),cor(numsc,docol)
   real*4               los(numsc,3*docol),dumv1(10*docol)
!f2py intent(in)     numsc,docol,fids,cols,nulls,latlon,i,cnt
!f2py intent(out)    unw,cor,los
   cnt = 0
   do m=1,numsc
      latoff = latlon(m,1); sline = latlon(m,2); eline = latlon(m,3)+1
      bcol = latlon(m,4); scol = latlon(m,5)+1
      if (i.ge.latoff.and.i.le.eline.and.(sline+i).gt.0) then
         dumv1 = nulls(m,1)
         read(fids(m,1),rec=i+sline) dumv1(bcol+1:bcol+cols(m))
            unw(m,:) = dumv1(scol:docol+scol-1)
         dumv1 = nulls(m,2)
         read(fids(m,2),rec=i+sline) dumv1(bcol+1:bcol+cols(m)) 
            cor(m,:) = dumv1(scol:docol+scol-1)
         dumv1 = nulls(m,3)
         read(fids(m,3),rec=i+sline) dumv1(3*bcol+1:3*(bcol+cols(m))) 
            los(m,:) = dumv1(3*(scol-1)+1:3*(docol+scol-1))
         cnt = cnt + 1
      else
         unw(m,:) = nulls(m,1)
      endif
   enddo
   end subroutine

!  ==============================================================================
   subroutine parsemetfile(metfile,numsc,delm,fids,filenms,cols,nulls,latlon)
!  latlon = (latoff,sline,eline,bcol,scol) for each scene
!  fids, filenms, and nulls in order:  unw,cor,los
   implicit none
   character*1          delm
   character*250        metfile
   character*999        str 
   integer              i,j,k,m,numsc,ios
   integer              fids(numsc,3),cols(numsc),latlon(numsc,5)
   real*4               nulls(numsc,5)
   character(len=250),dimension(numsc,3)::  filenms
!f2py intent(in)  mefile,numsc,delm
!f2py intent(out) fids,filenms,cols,nulls,latlon
   j = 41
   open(3,file=metfile,status='old')
   do i=1,numsc
      fids(i,1) = j; j = j + 1 
      fids(i,2) = j; j = j + 1
      fids(i,3) = j; j = j + 1
      read(3,'(A)',iostat=ios) str
      m = 1
      k = scan(str,delm) + m - 1
      filenms(i,1) = trim(adjustl(str(m:k-1)))
      m = k+1
      k = scan(str(m:),delm) + m - 1
      filenms(i,2) = trim(adjustl(str(m:k-1)))
      m = k+1
      k = scan(str(m:),delm) + m - 1
      filenms(i,3) = trim(adjustl(str(m:k-1)))
      m = k+1
      k = scan(str(m:),delm) + m - 1
      read(str(m:k-1),*,iostat=ios) cols(i) 
      m = k+1
      k = scan(str(m:),delm) + m - 1
      read(str(m:k-1),*,iostat=ios) nulls(i,1)
      m = k+1
      k = scan(str(m:),delm) + m - 1
      read(str(m:k-1),*,iostat=ios) nulls(i,2)
      m = k+1
      k = scan(str(m:),delm) + m - 1
      read(str(m:k-1),*,iostat=ios) nulls(i,3)
      m = k+1
      k = scan(str(m:),delm) + m - 1
      read(str(m:k-1),*,iostat=ios) latlon(i,1)
      m = k+1
      k = scan(str(m:),delm) + m - 1
      read(str(m:k-1),*,iostat=ios) latlon(i,2)
      m = k+1
      k = scan(str(m:),delm) + m - 1
      read(str(m:k-1),*,iostat=ios) latlon(i,3)
      m = k+1
      k = scan(str(m:),delm) + m - 1
      read(str(m:k-1),*,iostat=ios) latlon(i,4)
      m = k+1
      k = scan(str(m:),delm) + m - 1
      read(str(m:k-1),*,iostat=ios) latlon(i,5)
      m = k+1
      k = scan(str(m:),delm) + m - 1
      read(str(m:k-1),*,iostat=ios) nulls(i,4)
      m = k+1
      read(str(m:),*,iostat=ios) nulls(i,5)
   enddo
   close(3)
   end subroutine 

!  ==============================================================================
   subroutine interogate_data(unw,cor,los,nulls,nchk)
   implicit none
   integer        nchk
   real*4         unw,cor,los(3),nulls(3),tol
!f2py intent(in)  unw,cor,los,nulls
!f2py intent(out) nchk
   tol = 1.e-8
   nchk = 1
   if (abs(unw-nulls(1)).lt.tol) nchk = 0
   if (abs(cor-nulls(2)).lt.tol) nchk = 0
   if (abs(los(1)-nulls(3)).lt.tol) nchk = 0
   if (abs(los(2)-nulls(3)).lt.tol) nchk = 0
   if (abs(los(3)-nulls(3)).lt.tol) nchk = 0
   if (unw.ne.unw.or.cor.ne.cor) nchk = 0
   if (los(1).ne.los(1).or.los(2).ne.los(2).or.los(3).ne.los(3)) nchk = 0
   if ((unw+1).eq.unw.or.(cor+1).eq.cor.or.(los(1)+1).eq.los(1)) nchk = 0
   if ((los(2)+1).eq.los(2).or.(los(3)+1).eq.los(3)) nchk = 0 
   if (sqrt(sum(los**2)).lt.0.9.or.sqrt(sum(los**2)).gt.1.1) nchk = 0
   end subroutine

!  ==============================================================================
   subroutine get_rank(a,n,rnk)
!  returns rank(a) for a double precision nX3 matrix A
   implicit none
   integer n,rnk,info,i
   real*4  a(n,3)
   real*8  pa(n,3),s(3),u(n,3),vt(n,3),work(100)
!f2py intent(in)  a,n
!f2py intent(out) rnk
   pa = dble(a)
   call dgesvd('N','N',n,3,pa,n,s,u,n,vt,n,work,30,info)
   if (info.ne.0) then 
      print *,'Something is wrong in getrank; info = ',info
   else
   !   s = s/dsqrt(sum(s**2))
      rnk = 0
      do i=1,3
         if (s(i).gt.1.d-7) rnk = rnk + 1
      enddo
   endif
   end subroutine 

!  ==============================================================================
   subroutine print_status(i,j,s)
   implicit none
   integer        i,j,s
!f2py intent(in) i,j,s
   if(mod((100*i)/j,s).eq.0.or.i.eq.j.or.i.eq.1) then
      write(*,FMT="(A1,A,t21,I4,A)",ADVANCE="NO") achar(13), &
         & "  Percent Complete: ", (100*i)/j, " %"
   endif
   end subroutine

!  ==============================================================================
! end file _reconutils.f90
